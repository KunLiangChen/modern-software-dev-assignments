from __future__ import annotations

from typing import Any, Dict, List, Optional

import logging
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

from .. import db
from ..services.extract import extract_action_items, extract_action_items_llm


logger = logging.getLogger(__name__)

router = APIRouter(prefix="/action-items", tags=["action-items"])


class ActionItem(BaseModel):
    """Canonical API representation of an action item."""

    id: int
    note_id: Optional[int] = None
    text: str
    done: bool
    created_at: str


class ExtractedItem(BaseModel):
    """Minimal view of an action item returned from the extract endpoint."""

    id: int
    text: str


class ExtractRequest(BaseModel):
    """Request body for extracting action items from free-form text."""

    text: str
    save_note: bool = False


class ExtractResponse(BaseModel):
    """Response body for /action-items/extract."""

    note_id: Optional[int]
    items: List[ExtractedItem]


class MarkDoneRequest(BaseModel):
    """Request body for toggling an action item's completion state."""

    done: bool = True


class MarkDoneResponse(BaseModel):
    """Response body after marking an action item as done/undone."""

    id: int
    done: bool


@router.post("/extract", response_model=ExtractResponse)
def extract(payload: ExtractRequest) -> ExtractResponse:
    """
    Extract action items from the supplied text.

    The response shape deliberately mirrors the existing frontend contract:
    {
      "note_id": <optional int>,
      "items": [{"id": ..., "text": "..."}]
    }
    """
    text = payload.text.strip()
    if not text:
        raise HTTPException(status_code=400, detail="text is required")

    note_id: Optional[int] = None
    if payload.save_note:
        note_id = db.insert_note(text)

    try:
        items = extract_action_items(text)
        ids = db.insert_action_items(items, note_id=note_id)
    except Exception as exc:  # pragma: no cover - defensive, hard to trigger in unit tests
        logger.exception("Failed to extract or persist action items: %s", exc)
        raise HTTPException(
            status_code=500, detail="failed to extract action items"
        ) from exc

    extracted_items = [ExtractedItem(id=i, text=t) for i, t in zip(ids, items)]
    return ExtractResponse(note_id=note_id, items=extracted_items)


@router.post("/extract-llm", response_model=ExtractResponse)
def extract_llm(payload: ExtractRequest) -> ExtractResponse:
    """
    LLM-powered variant of the extract endpoint.

    It shares the same request and response schema as `/action-items/extract`,
    but uses `extract_action_items_llm()` under the hood. This makes it easy
    for clients (including the simple frontend) to switch between heuristic
    and LLM extraction strategies.
    """
    text = payload.text.strip()
    if not text:
        raise HTTPException(status_code=400, detail="text is required")

    note_id: Optional[int] = None
    if payload.save_note:
        note_id = db.insert_note(text)

    try:
        items = extract_action_items_llm(text)
        ids = db.insert_action_items(items, note_id=note_id)
    except Exception as exc:  # pragma: no cover - defensive, hard to trigger in unit tests
        logger.exception("Failed to LLM-extract or persist action items: %s", exc)
        raise HTTPException(
            status_code=500, detail="failed to extract action items via LLM"
        ) from exc

    extracted_items = [ExtractedItem(id=i, text=t) for i, t in zip(ids, items)]
    return ExtractResponse(note_id=note_id, items=extracted_items)


@router.get("", response_model=List[ActionItem])
def list_all(note_id: Optional[int] = None) -> List[ActionItem]:
    """
    List all action items, optionally filtered by note.

    Using a typed response model ensures a stable, discoverable schema for
    both human readers and tools (e.g. the autogenerated OpenAPI docs).
    """
    rows = db.list_action_items(note_id=note_id)
    return [
        ActionItem(
            id=r["id"],
            note_id=r["note_id"],
            text=r["text"],
            done=bool(r["done"]),
            created_at=r["created_at"],
        )
        for r in rows
    ]


@router.post("/{action_item_id}/done", response_model=MarkDoneResponse)
def mark_done(action_item_id: int, payload: MarkDoneRequest) -> MarkDoneResponse:
    """
    Mark an action item as completed or not.

    The request and response are explicitly modeled so that consumers know
    exactly which fields are accepted/returned.
    """
    db.mark_action_item_done(action_item_id, payload.done)
    return MarkDoneResponse(id=action_item_id, done=payload.done)

